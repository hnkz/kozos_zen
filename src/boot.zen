const mem = @import("std").mem;
const builtin = @import("std").builtin;
const uart = @import("uart.zen");
const xmodem = @import("xmodem.zen");
const lib = @import("kozoslib.zen");

comptime {
    asm (
        \\.section .boot, "ax",@progbits
        \\.global start
        \\start:
        \\  lui sp, 0x80004
        \\  jal main
        \\  j .
    );
    @export("_erodata", u32, builtin.GlobalLinkage.Strong);
    @export("_buffer_start", u32, builtin.GlobalLinkage.Strong);
    @export("_data_start", u32, builtin.GlobalLinkage.Strong);
    @export("_edata", u32, builtin.GlobalLinkage.Strong);
    @export("_bss_start", u32, builtin.GlobalLinkage.Strong);
    @export("_ebss", u32, builtin.GlobalLinkage.Strong);
}

extern fn start() noreturn;
extern var _erodata: u32;
extern var _buffer_start: u32;
extern var _data_start: u32;
extern var _edata: u32;
extern var _bss_start: u32;
extern var _ebss: u32;

fn init() void {
    const data_size: usize = @ptrToInt(&_edata) - @ptrToInt(&_data_start);
    const bss_size: usize = @ptrToInt(&_ebss) - @ptrToInt(&_bss_start);
    mem.copy(u8, @ptrCast([*]u8, &_data_start)[0..data_size], @ptrCast([*]u8, &_erodata)[0..data_size]);
    mem.secureZero(u8, @ptrCast([*]u8, &_bss_start)[0..bss_size]);

    // uart.setup_uart(115200);
    uart.setup_uart(9600);
}

export fn main() void {
    init();
    lib.puts("kzload (kozos boot loader) started.\n");
    var i: u32 = 1;
    var cmd_buf = [_]u8{0} ** 32;
    const bufsize: usize = @ptrToInt(&_data_start) - @ptrToInt(&_buffer_start);
    const loadbuf: [*]u8 = @ptrCast([*]u8, &_buffer_start);
    while(true) {
        lib.putxval(i, 0);
        lib.puts(" kzload> ");
        const cmd_size: usize = lib.gets(cmd_buf[0..cmd_buf.len]);

        if(mem.equal(u8, cmd_buf[0..cmd_size], "load")) {
            const size_or_err = xmodem.recv(loadbuf);
            lib.wait();
            if(size_or_err) | size | {
                lib.puts("xmodem receive succeeded.\n");
            } else | err | {
                lib.puts("[xmodem] error occured!\n");
                switch (err) {
                    xmodem.XmodemError.InvalidSoH => {
                        lib.puts("invalid soh \n");
                    },
                    xmodem.XmodemError.TooLongSoHWait => {
                        lib.puts("too logn soh wait\n");
                    },
                    xmodem.XmodemError.CanceledRecv => {
                        lib.puts("canceled recv\n");
                    },
                    xmodem.XmodemError.InvalidBlockNum => {
                        lib.puts("invalid block num\n");
                    },
                    xmodem.XmodemError.InvalidBlockNumCheckSum => {
                        lib.puts("invalid block num checksum\n");
                    },
                    xmodem.XmodemError.InvalidDataCheckSum => {
                        lib.puts("invalid data checksum\n");
                    },
                    xmodem.XmodemError.NoDataAvailable => {
                        lib.puts("nodata available\n");
                    }
                }
            }
        } else if(mem.equal(u8, cmd_buf[0..cmd_size], "dump")) {
            lib.puts("size: ");
            lib.putxval(bufsize, 0);
            lib.puts("\n");
            const dump_size = lib.dump(loadbuf, bufsize);
        } else if(mem.equal(u8, cmd_buf[0..cmd_size], "")) {
            lib.puts("\n");
        } else {
            lib.puts("unknown!\n");
        }
        i += 1;
    }
}

export fn abort() noreturn {
    unreachable;
}