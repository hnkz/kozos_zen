const regs = @import("regs.zen");

pub const UART0 = 0x10013000;

const TXDATA:u32 = 0x00;
const RXDATA:u32 = 0x04;
const TXCTRL:u32 = 0x08;
const RXCTRL:u32 = 0x0c;
const IE:u32 = 0x10;
const IP:u32 = 0x14;
const DIV:u32 = 0x18;

const TXEN:u32 = 0x1;
const RXEN:u32 = 0x1;
const NSTOP:u32 = 0x2;
const TX_FULL:u32 = 0x80000000;
const RX_EMPT:u32 = 0x80000000;
const RX_DATA:u32 = 0x00000ff;

const HFCLK = 16000000;


pub fn setup_uart(baudrate:u32) void {
    const gpio = @import("gpio.zen");

    gpio.setup_iof(gpio.IOF_UART0_RX|gpio.IOF_UART0_TX);

    var div = HFCLK/baudrate-1;
    regs.write(UART0+DIV, div);

    //regs.write(UART0+TXCTRL, TXEN|NSTOP);
    regs.write(UART0+TXCTRL, TXEN);
    regs.write(UART0+RXCTRL, RXEN);
}

pub fn send_byte(b: u8) void {
    while (true) {
        const txdata = regs.read(UART0+TXDATA);
        if ((txdata & TX_FULL) == 0)
            break;
    }
    regs.write(UART0+TXDATA, b);
}

pub fn recv_byte() ?u8 {
    const rxdata = regs.read(UART0+RXDATA);
    if ((rxdata & RX_EMPT) == 0) {
        const data = @intCast(u8, rxdata & RX_DATA);
        return data;
    } else {
        return null;
    }
}

pub fn recv_byte2() u8 {
    while(true) {
        const rxdata = regs.read(UART0+RXDATA);
        if((rxdata & RX_EMPT) == 0) {
            const data = @intCast(u8, rxdata & RX_DATA);
            return data;
        }
    }
}