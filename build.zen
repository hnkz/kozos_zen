const std = @import("std");
const Builder = std.build.Builder;
const Target = std.build.Target;
const builtin = @import("builtin");

pub fn build(b: *Builder) !void {

    // Adds 'flash' command.
    const flash = b.step("flash", "Flash the firmware into the target.");

    const target = try Target.parse("riscv32-freestanding-elfv2");

    const firmware = b.addExecutable("firmware", "src/boot.zen");
    firmware.setLinkerScriptPath("src/linker.ld");
    firmware.setBuildMode(builtin.Mode.Debug); 
    firmware.setTheTarget(target);
    firmware.setOutputDir("zen-cache");

    b.default_step.dependOn(&firmware.step);

    // Convert elf to Intel HEX format because nrfjprog requires this format.
    const gen_hex = b.addSystemCommand([_][]const u8{
        "objcopy", firmware.getOutputPath(),
        "-O", "ihex",
        "zen-cache/firmware.hex",
    });

    // Converting to HEX file requires compiled `elf` file.
    gen_hex.step.dependOn(&firmware.step);

    b.default_step.dependOn(&gen_hex.step);
    {
        // const flash_command = b.addSystemCommand([_][]const u8{
        //     "JLinkExe",
        //     "-device", "FE310",
        //     "-speed", "4000",
        //     "-if", "JTAG",
        //     "-jtagconf", "-1,-1",
        //     "-autoconnect", "1",
        //     "-CommanderScript", "upload.jlink"
        // });
        const flash_command = b.addSystemCommand([_][]const u8{
            "cp", "zen-cache/firmware.hex", "/media/pythongalo/HiFive"
        });
        flash_command.step.dependOn(&gen_hex.step);
        flash.dependOn(&flash_command.step);
    }
}